<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Platformer – Ataque y nuevos enemigos</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; color: #e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, sans-serif; overflow: hidden; }
    #hud { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 16px; align-items: center; background: rgba(10, 14, 30, .7); border: 1px solid #1f2a44; border-radius: 12px; padding: 8px 12px; box-shadow: 0 10px 30px rgba(0,0,0,.25); user-select: none; pointer-events: none; font-weight: 600; }
    #hud span { opacity: .9 }
    #help { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(10, 14, 30, .7); border: 1px solid #1f2a44; border-radius: 12px; padding: 8px 12px; font-size: 14px; text-align: center; line-height: 1.4; user-select: none; }
    #overlay { position: fixed; inset: 0; display: none; place-items: center; background: rgba(5, 8, 18, .85); }
    #overlay .card{ background: #0b132b; border: 1px solid #1f2a44; border-radius: 16px; padding: 20px; text-align:center; width: min(90vw, 520px); box-shadow: 0 10px 40px rgba(0,0,0,.35) }
    #overlay h2 { margin: 0 0 10px }
    #overlay button{ margin-top: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; padding: 10px 16px; font-weight: 700; cursor: pointer }
    canvas{ display:block; width:100vw; height:100vh; }
    #touch { position: fixed; inset: 0; pointer-events: none; }
    .btn { position: absolute; bottom: 24px; width: 68px; height: 68px; border-radius: 50%; background: rgba(59,130,246,.25); border: 1px solid rgba(59,130,246,.45); pointer-events: auto; touch-action: none; display: grid; place-items: center; font-weight: 800; user-select: none; }
    .btn:active{ filter: brightness(1.2) }
    #btnLeft{ left: 24px } #btnRight{ left: 108px } #btnJump{ right: 24px; width:82px; height:82px; }
    #btnAtk{ right: 124px; width:72px; height:72px; bottom: 26px; }
  </style>
</head>
<body>
  <div id="hud">
    <span id="coins">Monedas: 0</span>
    <span id="lives">Vidas: 3</span>
    <span id="timer">Tiempo: 0.0s</span>
  </div>
  <div id="help">Flechas izquierda/derecha para moverte · Espacio para saltar · X para atacar · R para reiniciar</div>
  <canvas id="game" width="1280" height="720"></canvas>
  <div id="overlay"><div class="card">
    <h2 id="ovTitle"></h2>
    <p id="ovMsg"></p>
    <button id="ovBtn">Jugar de nuevo</button>
  </div></div>
  <div id="touch" aria-hidden="true">
    <div class="btn" id="btnLeft">◀</div>
    <div class="btn" id="btnRight">▶</div>
    <div class="btn" id="btnJump">⤒</div>
    <div class="btn" id="btnAtk">✶</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudCoins = document.getElementById('coins');
  const hudLives = document.getElementById('lives');
  const hudTimer = document.getElementById('timer');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovMsg = document.getElementById('ovMsg');
  const ovBtn = document.getElementById('ovBtn');

  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = window.innerWidth, h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  const keys = new Set();
  window.addEventListener('keydown', e => {
    if (["ArrowLeft","ArrowRight"," ","Space","KeyR","KeyX"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
  });
  window.addEventListener('keyup', e => keys.delete(e.code));

  function bindTouch(id, on, off) {
    const el = document.getElementById(id);
    const start = (e)=>{ e.preventDefault(); on(); }
    const end = (e)=>{ e.preventDefault(); off(); }
    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('touchend', end, {passive:false});
    el.addEventListener('touchcancel', end, {passive:false});
    el.addEventListener('mousedown', start);
    el.addEventListener('mouseup', end);
    el.addEventListener('mouseleave', end);
  }
  let touchLeft=false, touchRight=false, touchJump=false, touchAtk=false;
  bindTouch('btnLeft', ()=>touchLeft=true, ()=>touchLeft=false);
  bindTouch('btnRight', ()=>touchRight=true, ()=>touchRight=false);
  bindTouch('btnJump', ()=>touchJump=true, ()=>touchJump=false);
  bindTouch('btnAtk', ()=>touchAtk=true, ()=>touchAtk=false);

  const G = 1800;
  const MOVE = 420;
  const JUMP = 760;
  const FRICTION = 0.82;

  const state = { startedAt: performance.now(), time: 0, coins: 0, lives: 3, camera: {x: 0, y: 0}, goalReached: false };
  const player = { x: 60, y: -200, w: 34, h: 46, vx: 0, vy: 0, onGround: false, canDouble: true, facing: 1 };

  // Ataque (caja de golpe) con cooldown
  const attack = {
    active: false,
    timer: 0,
    duration: 0.14,   // segundos activo
    cooldown: 0.28,   // segundos entre ataques
    cdLeft: 0
  };

  const platforms = [
    {x:-200, y:300, w:1800, h:40},
    {x:350, y:220, w:120, h:16},
    {x:520, y:160, w:120, h:16},
    {x:700, y:120, w:150, h:16},
    {x:940, y:260, w:160, h:16},
    {x:1180, y:220, w:180, h:16},
    {x:1420, y:180, w:180, h:16},
    {x:1750, y:140, w:160, h:16},
    {x:1950, y:200, w:180, h:16},
    {x:2150, y:260, w:180, h:16},
    {x:2400, y:220, w:220, h:16},
    {x:2700, y:180, w:200, h:16},
    {x:3000, y:140, w:200, h:16},
  ];

  const coins = [
    {x:380,y:190,t:false},{x:550,y:130,t:false},{x:730,y:90,t:false},
    {x:970,y:230,t:false},{x:1210,y:190,t:false},{x:1450,y:150,t:false},
    {x:1780,y:110,t:false},{x:1980,y:170,t:false},{x:2180,y:230,t:false},
    {x:2430,y:190,t:false},{x:2730,y:150,t:false},{x:3030,y:110,t:false}
  ];

  const spikes = [
    {x:860, y:300, w:60, h:40},
    {x:1600, y:300, w:60, h:40},
    {x:2320, y:300, w:60, h:40},
  ];

  // Enemigos: walkers y turrets (con balas)
  const enemies = [
    {type:'walker', x:1060, y:244, w:28, h:24, dir:1, left:1040, right:1200, speed:70, hp:2, alive:true, iFrames:0},
    {type:'walker', x:1980, y:184, w:28, h:24, dir:-1, left:1950, right:2050, speed:80, hp:2, alive:true, iFrames:0},
    {type:'turret', x:1550, y:268, w:20, h:32, dir:-1, fireCd:0.0, hp:3, alive:true, iFrames:0},
    {type:'turret', x:2380, y:268, w:20, h:32, dir: 1, fireCd:0.0, hp:3, alive:true, iFrames:0},
  ];

  const bullets = []; // {x,y,vx,vy,w,h,owner:'turret'}

  const goal = {x:3200, y:100, w:36, h:72};

  function aabb(ax,ay,aw,ah,bx,by,bw,bh){ return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by; }

  function reset() {
    Object.assign(player, {x:60,y:-200,vx:0,vy:0,onGround:false,canDouble:true,facing:1});
    Object.assign(state, {camera:{x:0,y:0}, goalReached:false, startedAt:performance.now(), time:0, coins:0, lives:3});
    coins.forEach(c=>c.t=false);
    enemies.forEach(e=>{ e.alive = true; e.hp = e.type==='walker'?2:3; e.iFrames=0; if (e.type==='walker'){ e.x = (e.left + e.right)/2; } });
    bullets.length = 0;
    overlay.style.display = 'none';
  }
  function loseLife() {
    state.lives -= 1;
    if (state.lives <= 0) { showOverlay('Perdiste', 'Te quedaste sin vidas.'); return; }
    Object.assign(player, {x: Math.max(60, player.x-120), y:-120, vx:0, vy:0, onGround:false, canDouble:true});
  }
  function showOverlay(title, msg) {
    ovTitle.textContent = title;
    ovMsg.textContent = msg + `\nTiempo: ${state.time.toFixed(1)}s · Monedas: ${state.coins}`;
    overlay.style.display = 'grid';
  }
  ovBtn.addEventListener('click', reset);

  function doAttack(){
    if (attack.cdLeft > 0 || attack.active) return;
    attack.active = true;
    attack.timer = attack.duration;
    attack.cdLeft = attack.cooldown;
  }

  function step(dt){
    state.time = (performance.now() - state.startedAt) / 1000;

    // Inputs
    const left = keys.has('ArrowLeft') || touchLeft;
    const right = keys.has('ArrowRight') || touchRight;
    let wantJump = keys.has('Space') || keys.has(' ') || touchJump;
    const wantAtk = keys.has('KeyX') || touchAtk;

    if (left && !right) { player.vx = -MOVE; player.facing = -1; }
    else if (right && !left) { player.vx = MOVE; player.facing = 1; }
    else { player.vx *= player.onGround ? FRICTION : 0.98; if (Math.abs(player.vx) < 1) player.vx = 0; }

    if (wantJump) {
      if (player.onGround) { player.vy = -JUMP; player.onGround = false; player.canDouble = true; }
      else if (player.canDouble) { player.vy = -JUMP * 0.9; player.canDouble = false; }
      wantJump = false; touchJump = false; keys.delete('Space'); keys.delete(' ');
    }

    if (wantAtk) { doAttack(); keys.delete('KeyX'); }

    // Attack timers
    if (attack.cdLeft > 0) attack.cdLeft -= dt;
    if (attack.active) {
      attack.timer -= dt;
      if (attack.timer <= 0) attack.active = false;
    }

    // Physics
    player.vy += G * dt;
    let nextX = player.x + player.vx * dt;
    let nextY = player.y + player.vy * dt;

    player.onGround = false;
    const px = {x: nextX, y: player.y, w: player.w, h: player.h};
    for (const p of platforms) {
      if (aabb(px.x, px.y, px.w, px.h, p.x, p.y, p.w, p.h)) {
        if (player.vx > 0) nextX = p.x - player.w - 0.01; else if (player.vx < 0) nextX = p.x + p.w + 0.01;
        player.vx = 0;
      }
    }
    const py = {x: nextX, y: nextY, w: player.w, h: player.h};
    for (const p of platforms) {
      if (aabb(py.x, py.y, py.w, py.h, p.x, p.y, p.w, p.h)) {
        if (player.vy > 0) { nextY = p.y - player.h - 0.01; player.vy = 0; player.onGround = true; }
        else if (player.vy < 0) { nextY = p.y + p.h + 0.01; player.vy = 0; }
      }
    }

    player.x = nextX; player.y = nextY;
    if (player.y > 900) loseLife();

    // Coins
    for (const c of coins) if (!c.t && aabb(player.x, player.y, player.w, player.h, c.x-8, c.y-8, 16, 16)) { c.t = true; state.coins++; }

    // Enemies logic
    for (const e of enemies) {
      if (!e.alive) continue;
      if (e.iFrames > 0) e.iFrames -= dt;

      if (e.type === 'walker') {
        e.x += e.speed * e.dir * dt;
        if (e.x < e.left) { e.x = e.left; e.dir = 1; }
        if (e.x > e.right) { e.x = e.right; e.dir = -1; }
      } else if (e.type === 'turret') {
        e.fireCd = (e.fireCd || 0) - dt;
        const dist = Math.abs(player.x - e.x);
        if (dist < 520 && e.fireCd <= 0) {
          const dir = player.x > e.x ? 1 : -1;
          bullets.push({x:e.x + (dir>0?e.w: -6), y:e.y+10, vx: 360*dir, vy:0, w:8, h:4, owner:'turret'});
          e.fireCd = 1.1; // tiempo entre disparos
        }
      }

      // Player stomp
      if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
        if (player.vy > 120) { // stomp
          e.hp -= 2; e.iFrames = 0.2;
          player.vy = -JUMP*0.6;
          if (e.hp <= 0) { e.alive = false; state.coins += 1; }
        } else {
          loseLife();
        }
      }
    }

    // Player attack hitbox
    if (attack.active) {
      const range = 26;
      const w = 30, h = 24;
      const atkBox = {
        x: player.x + (player.facing>0 ? player.w : -w) + (player.facing>0?2:-2),
        y: player.y + 10,
        w, h
      };
      for (const e of enemies) {
        if (!e.alive) continue;
        if (e.iFrames > 0) continue;
        if (aabb(atkBox.x, atkBox.y, atkBox.w, atkBox.h, e.x, e.y, e.w, e.h)) {
          e.hp -= 1; e.iFrames = 0.2;
          if (e.hp <= 0) { e.alive = false; state.coins += 2; }
        }
      }
    }

    // Bullets update
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt; b.y += b.vy * dt;
      // collide with platforms
      let hit = false;
      for (const p of platforms) {
        if (aabb(b.x, b.y, b.w, b.h, p.x, p.y, p.w, p.h)) { hit = true; break; }
      }
      // collide with player
      if (aabb(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h)) { loseLife(); hit = true; }
      if (hit || b.x < -400 || b.x > 4000) bullets.splice(i,1);
    }

    // Spikes
    for (const s of spikes) if (aabb(player.x, player.y, player.w, player.h, s.x, s.y, s.w, s.h)) loseLife();

    // Goal
    if (!state.goalReached && aabb(player.x, player.y, player.w, player.h, goal.x, goal.y, goal.w, goal.h)) {
      state.goalReached = true;
      showOverlay('Meta alcanzada', 'Buen trabajo');
    }

    // Camera follow
    const marginX = 220;
    const centerX = state.camera.x + canvas.clientWidth/2;
    if (player.x - centerX > marginX) state.camera.x = player.x - marginX - canvas.clientWidth/2;
    if (centerX - player.x > marginX) state.camera.x = player.x + marginX - canvas.clientWidth/2;
    state.camera.x = Math.max(-300, Math.min(4000, state.camera.x));

    // HUD
    hudCoins.textContent = `Monedas: ${state.coins}`;
    hudLives.textContent = `Vidas: ${state.lives}`;
    hudTimer.textContent = `Tiempo: ${state.time.toFixed(1)}s`;

    // Reset
    if (keys.has('KeyR')) { reset(); keys.delete('KeyR'); }
  }

  function draw(){
    const camX = Math.floor(state.camera.x);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#0d1b2a'); g.addColorStop(1, '#111827');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    ctx.save(); ctx.translate(-camX, 0);

    // Stars parallax
    ctx.globalAlpha = .25;
    for (let i=0;i<80;i++) {
      const x = (i*97)%5000; const y = (i*53)%h;
      ctx.fillStyle = '#dbeafe';
      ctx.fillRect(x*0.5, y*0.7 + 10*Math.sin((x+y+state.time*30)/200), 2,2);
    }
    ctx.globalAlpha = 1;

    // Platforms
    for (const p of platforms) { ctx.fillStyle = '#1f2937'; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.fillStyle = '#334155'; ctx.fillRect(p.x, p.y, p.w, 4); }

    // Spikes
    for (const s of spikes) {
      ctx.fillStyle = '#8b1e2d'; const tH = s.h; const triW = 12; const n = Math.floor(s.w/triW);
      for (let i=0;i<n;i++){ const x = s.x + i*triW; ctx.beginPath(); ctx.moveTo(x, s.y+s.h); ctx.lineTo(x+triW/2, s.y+s.h - tH); ctx.lineTo(x+triW, s.y+s.h); ctx.closePath(); ctx.fill(); }
    }

    // Coins
    for (const c of coins) { if (c.t) continue; ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(c.x, c.y, 8, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fde68a'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(c.x, c.y, 6, 0, Math.PI*2); ctx.stroke(); }

    // Enemies
    for (const e of enemies) {
      if (!e.alive) continue;
      if (e.type==='walker') {
        ctx.fillStyle = e.iFrames>0 ? '#bfb1ff' : '#a78bfa';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = '#c4b5fd'; ctx.fillRect(e.x+3, e.y+6, e.w-6, 6);
      } else if (e.type==='turret') {
        ctx.fillStyle = e.iFrames>0 ? '#9bd6bf' : '#34d399';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = '#065f46'; ctx.fillRect(e.x+ (e.dir>0? e.w-4 : 0), e.y+8, 4, 8);
      }
    }

    // Bullets
    for (const b of bullets) { ctx.fillStyle = '#fca5a5'; ctx.fillRect(b.x, b.y, b.w, b.h); }

    // Goal
    ctx.fillStyle = '#22c55e'; ctx.fillRect(goal.x, goal.y, 6, goal.h);
    ctx.fillStyle = '#16a34a'; ctx.beginPath(); ctx.moveTo(goal.x+6, goal.y+6); ctx.lineTo(goal.x+36, goal.y+16); ctx.lineTo(goal.x+6, goal.y+26); ctx.closePath(); ctx.fill();

    // Player
    ctx.save(); ctx.translate(player.x + player.w/2, player.y + player.h/2); ctx.scale(player.facing, 1); ctx.translate(-player.w/2, -player.h/2);
    ctx.fillStyle = '#60a5fa'; ctx.fillRect(0, 0, player.w, player.h);
    ctx.fillStyle = '#e5e7eb'; ctx.fillRect(8,10,6,6); ctx.fillRect(20,10,6,6);
    ctx.fillStyle = '#1f2937'; ctx.fillRect(8,28,20,4);
    // Slash visual
    if (attack.active) {
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#93c5fd';
      const sx = player.w + 4; const sw = 26; const sh = 18;
      ctx.fillRect(sx, 12, sw, sh);
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    ctx.restore();
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000); last = now;
    step(dt); draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
